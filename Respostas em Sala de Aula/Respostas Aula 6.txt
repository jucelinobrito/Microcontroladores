Data: 31/03/2017

Para cada questão, escreva funções em C e/ou sub-rotinas na linguagem Assembly do MSP430. Reaproveite funções e sub-rotinas de uma questão em outra, se assim desejar. Leve em consideração que as sub-rotinas são utilizadas em um código maior, portanto utilize adequadamente os registradores R4 a R11. As instruções da linguagem Assembly do MSP430 se encontram ao final deste texto.

1. (a) Escreva uma função em C que calcule a raiz quadrada 'x' de uma variável 'S' do tipo float, utilizando o seguinte algoritmo: após 'n+1' iterações, a raiz quadrada de 'S' é dada por

	x(n+1) = (x(n) + S/x(n))/2

O protótipo da função é:

	unsigned int Raiz_Quadrada(unsigned int S);
	{
		int n = 0;
		float x[16];

        x[0]=S/2; //chute inicial

		while (n < 15)
		{
           		x[n+1] = (x[n] + (S/x[n]))/2;  // iteração
			n++;
		}

		printf("Raiz e %f",x[n]);
		return 0;
	}


(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável 'S' é fornecida pelo registrador R15, e a raiz quadrada de 'S' (ou seja, a variável 'x') é fornecida pelo registrador R15 também.

	Raiz_Quadrada:
		mov.w #0026h,R15    ;Armazena o valor 36 (que quer descobrir a raiz) em R15
		mov.w #0000h,R14    ;seta 0 na variável n
		tst.w R15
		jz Final_2
		;;estimativa inicial
		mov.w R15,R12      ;coloca R15 como dividendo
		mov.w #2,R11       ;define o divisor como 2
		call Divisao_1
		mov.w R13,R14(R10)   ; 0(R10) -> Posicao inicial do vetor R10
						

	While:
		cmp #32,R14        ;compara R14 com o decimal 32
		jeq Final_1	   ;R14 = 32 -> pula para o final
		
		mov.w R15,R12      ; R15 -> Dividendo
		mov.w R14(R10),R11 ; Posição R14 de (R10) -> Divisor  S/x[n]
		call Divisao_1
		mov.w R13, R9      ; R9 = S/x[n]
		add.w R14(R10),R9  ; R9 = R9 + R14(R10)
		mov.w R9,R12       ; Dividendo
		mov.w #2,R11       ; Divisor
		call Divisao_1     ;
		incd.w R14         ; incrementa R14 em dois
		mov.w R13,R14(R10) ; R14(R10) = R13 (Resultado da ultima divisao
		jmp While
	
	Final_1: 
		mov.w R14(R10), R15; Armazena o valor final em R15
	Final_2:
		ret


	Divisao_1:
		mov.w #0,R13     ; zera o contador 
	Divisao_2:
		sub.w R11,R12    ; R12 = R12 - R11 -> R12 Dividendo, R11 Divisor
		cmp #0,R12       ; Compara R12 com 0
		jl Final_Divisao ;
		jeq Final_Divisao ;
		mov.w #1;R13     ; Soma 1 ao contador
		jmp Divisao_2     
	Final_Divisao:	
		ret
	

	
		

2. (a) Escreva uma função em C que calcule 'x' elevado à 'N'-ésima potência, seguindo o seguinte protótipo: 

	int potencia(int x, int N)
{
    int tst;
    if(N==0)
        return 1;
    else if(N==1)
        return x;
        else
        {
            tst = N%2;
            if (tst==0)
            return potencia_par(x,N);
            else
                return (x*potencia_par(x,N-1));
        }


}

int potencia_par(int y, int M)
{
        int val = 1;
        int n;
        n = M/2;
        for(n; n>0;n-- )
           {
              val = val*mult(y,y);
            }
    return val;
}

int mult(int a, int b)
{
    if(b==0)
        return 0;
    else
        return a + mult(a,b-1);
}

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. 'x' e 'n' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida no registrador R15.

	mov.w R15,R11             ;faz a = R15
potencia:
	mov.w R15,R10             ;faz b = R15
	call MULT_unsigned	  ;calcula a*b
	dec.w R14		  ;decrementa a potencia
	cmp #1,R14		  ;se for igual a 1 pula para o final
	jeq final_potencia
	jmp potencia
final_potencia:
	mov.w R11,R15             ;resultado em R15
	
	
MULT_unsigned:
	tst.w R10   ; b == 0?
	jnz MULT_unsigned_else ; Se b não é zero, vá para o else
	clr.w R11   ;return 0
	ret
MULT_unsigned_else:
	push.w R11 ; Guarde a na pilha
	dec.w R10  ; b--
	call MULT_unsigned  ;Calcule a*(b-1)
	pop.w R10  ; Recupera a na pilha
	add.w R10,R11 ; return a + a*(b-1)
	ret
	

3. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula a divisão de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do registrador R15.

	mov.w R15,R12
	mov.w R14, R11
	call Divisao_1
Divisao_1:
	mov.w #0,R13     ; zera o contador 
Divisao_2:
	sub.w R11,R12    ; R12 = R12 - R11 -> R12 Dividendo, R11 Divisor
	cmp #0,R12       ; Compara R12 com 0
	jl Final_Divisao ;
	jeq Final_Divisao ;
	mov.w #1;R13     ; Soma 1 ao contador
	jmp Divisao_2     
Final_Divisao:	
	mov.w R13,R15
	ret

4. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o resto da divisão de 'a' por 'b', onde 'a', 'b' e o valor de saída são inteiros de 16 bits. 'a' e 'b' são fornecidos através dos registradores R15 e R14, respectivamente, e a saída deverá ser fornecida através do registrador R15.

resto:
	sub.w R11,R12    ; R12 = R12 - R11 -> R12 Dividendo, R11 Divisor
	cmp #0,R12       ; Compara R12 com 0
	jeq final_resto ; se não houver resto
	cmp R11,R12       ; compara R12 com R11
	jl final_resto_1 ; se R12 for menor que R11 existe resto
	jmp resto
final_resto:
	clr.w R13   ;resultado do resto = 0
	ret	
final_resto_1:
	mov.w R12,R13  ; resultado do resto = R12
	ret

5. (a) Escreva uma função em C que indica a primalidade de uma variável inteira sem sinal, retornando o valor 1 se o número for primo, e 0, caso contrário. Siga o seguinte protótipo:

int Primalidade(unsigned int x);
	{
    int i,div=0;
    for (i = 1; i <= x; i++) {
    if (x % i == 0) {
     div++;
    }
  }

  if (div == 2)
    return 1;
  else
    return 0;
}

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. A variável de entrada é fornecida pelo registrador R15, e o valor de saída também.

	mov.w #0,R10  ; div = 0
Primalidade:
	
	mov.w #1,R14  ; i = 1
	mov.w R15,R12 ; passando parametros para a funçao resto
	mov.w R14,R11
	call resto
	tst.w R13    ;verifica se o resto é zero
	jz contador_1
	cmp R14,R15 ; compara i com x
	jeq final   ; se forem iguais, pule para o final
	inc.w R14   ;i++
	jmp Primalidade

contador_1:
	
	inc.w R10 ; div++	
	cmp R14,R15 ; compara i com x
	jeq final   ; se forem iguais, pule para o final
	inc.w R14; i++
	jmp Primalidade	

final:
	sub.w #2,R10 ; 
	tst.w R10    ;
	jz primo     ;
	clr.w R15    ;
	ret

primo: 
	mov.w #1,R15
	ret 
	
	
	

6. Escreva uma função em C que calcula o duplo fatorial de n, representado por n!!. Se n for ímpar, n!! = 1*3*5*...*n, e se n for par, n!! = 2*4*6*...*n. Por exemplo, 9!! = 1*3*5*7*9 = 945 e 10!! = 2*4*6*8*10 = 3840. Além disso, 0!! = 1!! = 1.
O protótipo da função é:

unsigned long long DuploFatorial(unsigned long long n);
{
    if (n<2) return 1;
    else
        return n*duplofatorial(n-2);
}

Fatorial:
	cmp #2,R15   ;Testar se n<2
	jge L1	     ;Se N>=, pule para L1
	mov.w #1,R15 ;return 1;
	ret	     ;retorne para onde a função foi chamada
L1:
	push.w R15   ;Guarde n (R15) na pilha
	decd.w R15   ;Calcule n-2 para
	call Fatorial ; chamar Fatorial(n-2)
	pop.w R14    ;Recupere n na pilha
	call MULT_unsigned ;Calcular n*Fatorial(n-2)
	ret

7. (a) Escreva uma função em C que calcula a função exponencial da seguinte forma:
	
Considere o cálculo até o termo n = 20. O protótipo da função é double ExpTaylor(double x);

double ExpTaylor (double x)
{
    int i;
    float res = 0;
    for(i=0;i<20;i++)
    {
        res += (potencia(x,i)/fatorial(i));
    }
    return res;
}

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430, mas considere que os valores de entrada e de saída são inteiros de 16 bits. A variável de entrada é fornecida pelo registrador R15, e o valor de saída também.

ExpTaylor:
	mov.w #0,R9  ; res = 0
	mov.w #0,R14 ; i = 0
	mov.w R15,R11
	call potencia ;retorna resultado em R11
	call fatorial ;retorna resultado em R10
	mov.w R11,R12
	mov.w R10,R11
	call Divisao_1;retorna resultado em R13
	add.w R13,R9 ; R9 = R9 + R13
	cmp #19,R14
	jeq final
	inc.w R14
	jmp ExpTaylor
final: 
	mov.w R9,R15


8. Escreva uma sub-rotina na linguagem Assembly do MSP430 que indica se um vetor esta ordenado de forma decrescente. Por exemplo:
[5 4 3 2 1] e [90 23 20 10] estão ordenados de forma decrescente.
[1 2 3 4 5] e [1 2 3 2] não estão.
O primeiro endereço do vetor é fornecido pelo registrador R15, e o tamanho do vetor é fornecido pelo registrador R14. A saída deverá ser fornecida no registrador R15, valendo 1 quando o vetor estiver ordenado de forma decrescente, e valendo 0 em caso contrário.

	mov.w R15,R5 ; mover o endereço inicial do vetor R15 para o vetor temporario R5
Ord_Vetor:
	cmp 2(R5),0(R5); Compara o valor do endereço que R5 está armazenando + 0 casas com o valor do endereço que R5 está armazenando + 2 casas
	jl Final_1; se o valor na segunda posição de R5 for maior que o da primeira posição, o vetor nao está em ordem decrescente, pule para final_1
	incd.w R5	; A posição inicial do vetor aumentou duas casas
	decd.w R14      ;
	tst.w R14
	jz Final_2
	jmp Ord_Vetor
	
Final_1:
	mov.w #0,R15 ; não esta ordenado de forma descrescente
Final_2:
	mov.w #1,R15 ; está ordenado de forma descrescente
9. Escreva uma sub-rotina na linguagem Assembly do MSP430 que calcula o produto escalar de dois vetores, 'a' e 'b':
	
O primeiro endereço do vetor 'a' deverá ser passado através do registrador R15, o primeiro endereço do vetor 'b' deverá ser passado através do registrador R14, e o tamanho do vetor deverá ser passado pelo registrador R13. A saída deverá ser fornecida no registrador R15.

	mov.w R15,R5
	mov.w R14,R4
Prod_Escalar:
	call MULT_unsigned
	incd.w
	incd.w
	call MULT_unsigned
	add.w
	tst.w R13
	jz Final
	decd.w R13
	jmp Prod_Escalar
	
Final: 
10. (a) Escreva uma função em C que indica se um vetor é palíndromo. Por exemplo:
	[1 2 3 2 1] e [0 10 20 20 10 0] são palíndromos.
	[5 4 3 2 1] e [1 2 3 2] não são.
Se o vetor for palíndromo, retorne o valor 1. Caso contrário, retorne o valor 0. O protótipo da função é:

	int Palindromo(int vetor[ ], int tamanho);

(b) Escreva a sub-rotina equivalente na linguagem Assembly do MSP430. O endereço do vetor de entrada é dado pelo registrador R15, o tamanho do vetor é dado pelo registrador R14, e o resultado é dado pelo registrador R15.